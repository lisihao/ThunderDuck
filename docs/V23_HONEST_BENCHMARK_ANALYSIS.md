# ThunderDuck V23 诚实基准测试分析

> 日期: 2026-01-28

## 一、问题陈述

### 1.1 当前基准测试的缺陷

```
当前对比方式 (不公平):

DuckDB:                       ThunderDuck:
┌─────────────────────┐      ┌─────────────────────┐
│ SELECT SUM(...)     │      │ // 手写代码         │
│ FROM lineitem       │      │ for (i=0; i<n; i++) │
│ WHERE date BETWEEN  │  vs  │   sum += data[i];   │
│ ...                 │      │                     │
└─────────────────────┘      └─────────────────────┘
      ↓                            ↓
  SQL 优化器                    直接执行
      ↓                            ↓
  向量化执行                    SIMD 优化
```

**问题：我们在比较苹果和橘子**

- DuckDB: 完整 SQL 解析 → 优化器 → 执行
- ThunderDuck: 手写实现 → 跳过了解析和优化

### 1.2 真正公平的对比应该是

```
公平对比方式:

相同的 SQL ─────┬──────▶ DuckDB 执行引擎
                │
                └──────▶ ThunderDuck 执行引擎 (需要深度集成)
```

## 二、诚实评估

### 2.1 ThunderDuck 真正的优势场景

| 场景 | ThunderDuck 优势 | 原因 |
|------|------------------|------|
| 单表 Filter + SUM | ✅ 1.5-2x | SIMD + 8线程并行 |
| 低基数 GROUP BY | ✅ 2-3x | 固定数组避免哈希 |
| 纯 SUM/COUNT | ✅ 1.5-2x | 8路展开 + 自动向量化 |
| GPU SEMI JOIN | ✅ 2-3x | Metal 并行 |

### 2.2 ThunderDuck 的劣势场景

| 场景 | 问题 | 原因 |
|------|------|------|
| 多表 JOIN | ❌ 0.3-0.5x | 需要提取数据、多次遍历 |
| 复杂子查询 | ❌ 无法优化 | 需要完整 SQL 优化器 |
| 字符串操作 | ❌ 无优势 | DuckDB 已高度优化 |
| 数据提取开销 | ❌ 固有开销 | 无法避免 |

### 2.3 数据提取开销分析

```
数据流 (当前架构):

DuckDB 存储 ───▶ 提取到内存 ───▶ ThunderDuck 算子 ───▶ 结果
                    │
                    └── 开销来源:
                        1. 内存分配 (malloc)
                        2. 数据拷贝 (memcpy)
                        3. 格式转换
                        4. 缓存失效
```

**SF=1 数据提取时间估算:**

| 表 | 行数 | 提取时间 |
|----|------|----------|
| lineitem | 6M | ~50ms |
| orders | 1.5M | ~15ms |
| customer | 150K | ~2ms |
| **总计** | | **~70ms** |

这 70ms 是固有开销，无法避免（除非深度集成）。

## 三、公平基准测试方案

### 3.1 方案 A: 算子级别对比

直接测试算子性能，不通过 SQL：

```cpp
// Filter 算子对比
benchmark("Filter i32 > threshold") {
    DuckDB: SELECT * FROM data WHERE col > threshold
    ThunderDuck: simd_filter_gt_i32(data, n, threshold, result)
}

// SUM 算子对比
benchmark("SUM i64") {
    DuckDB: SELECT SUM(col) FROM data
    ThunderDuck: sum_i64_v21(data, n)
}
```

**这是真正公平的算子对比。**

### 3.2 方案 B: 端到端场景对比

对于特定场景，提供端到端的解决方案：

```cpp
// 场景: 单表过滤聚合 (Q6 类型)
benchmark("Filter + SUM 场景") {
    // 完整流程，包括数据加载
    DuckDB: 完整 SQL 执行
    ThunderDuck: 数据提取 + 算子执行
}
```

**这个对比包含了数据提取开销，是诚实的端到端对比。**

### 3.3 方案 C: 深度集成后的对比

```cpp
// 未来: 深度集成后
benchmark("深度集成 Q6") {
    DuckDB: 使用原生算子执行
    DuckDB+ThunderDuck: 使用 ThunderDuck 算子替换执行
}
```

**这需要实现 DuckDB 扩展，是长期目标。**

## 四、结论

### 4.1 当前状态

- ThunderDuck 算子本身是高效的
- 但作为独立系统与 DuckDB 竞争是不公平的
- 数据提取开销抵消了算子优势

### 4.2 正确的定位

ThunderDuck 应该是 **DuckDB 的加速器**，而不是竞争者：

```
正确架构:
┌─────────────────────────────────────────┐
│                 DuckDB                  │
│  ┌───────────────────────────────────┐  │
│  │        Query Optimizer            │  │
│  └───────────────┬───────────────────┘  │
│                  │                      │
│  ┌───────────────▼───────────────────┐  │
│  │      Execution Engine             │  │
│  │  ┌─────────┐  ┌─────────────────┐ │  │
│  │  │ DuckDB  │  │  ThunderDuck    │ │  │
│  │  │ 默认    │  │  替换算子       │ │  │
│  │  └─────────┘  └─────────────────┘ │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### 4.3 下一步行动

1. **短期**: 实现公平的算子级别基准测试
2. **中期**: 实现 DuckDB 扩展，替换特定算子
3. **长期**: 实现晚期物化，深度集成

---

*ThunderDuck - 诚实评估，正确定位*
