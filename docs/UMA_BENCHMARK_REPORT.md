# ThunderDuck UMA 全面性能基准测试报告

> **测试日期**: 2026-01-24
> **测试平台**: Apple M4, macOS
> **测试版本**: UMA 统一内存架构优化版

---

## 一、系统状态

| 组件 | 状态 | 说明 |
|------|------|------|
| UMA 内存管理器 | ✓ 可用 | 统一内存架构支持 |
| Filter GPU | ✓ 可用 | Metal 着色器编译 |
| Aggregate GPU | ✓ 可用 | GPU 并行归约 |
| Join GPU | ✓ 可用 | 零拷贝哈希连接 |
| TopK GPU | ✓ 可用 | GPU 并行过滤 |

---

## 二、Filter 算子测试

**SQL 语义**: `SELECT * FROM t WHERE col > value`

### 测试结果

| 测试用例 | 数据量 | 版本 | 加速器 | 时间(ms) | 吞吐量(M/s) | 带宽(GB/s) |
|----------|--------|------|--------|----------|-------------|------------|
| F1 | 100K | v3 | CPU SIMD | 0.042 | 2,405 | 9.6 |
| F2 | 1M | v3 | CPU SIMD | 0.407 | 2,455 | 9.8 |
| F3 | 10M | v3 | CPU SIMD | 3.782 | 2,644 | 10.6 |
| F4 | 50M | v3 | CPU SIMD | 19.527 | 2,560 | 10.2 |

### 分析

- **选择率**: 约 50%
- **CPU SIMD 性能**: 稳定 ~2,500 M rows/s
- **带宽利用率**: ~10 GB/s (理论峰值 400 GB/s 的 2.5%)
- **GPU 优化空间**: 大，当前 CPU 已很快，需要更大数据量才能发挥 GPU 优势

### 优化建议

1. **提高 GPU 阈值**: 当前 100K 太低，建议 >= 10M
2. **优化 GPU kernel**: 使用 SIMD4 向量化减少线程数
3. **批量处理**: 增加每线程处理元素数减少调度开销

---

## 三、Aggregate 算子测试

**SQL 语义**: `SELECT SUM(col), MIN(col), MAX(col) FROM t`

### 测试结果

| 测试用例 | 数据量 | 操作 | 版本 | 时间(ms) | 吞吐量(M/s) | 带宽(GB/s) |
|----------|--------|------|------|----------|-------------|------------|
| A1 | 100K | SUM | v2 | 0.004 | 23,305 | 93.2 |
| A1 | 100K | MINMAX | v2 | 0.003 | 29,630 | 118.5 |
| A2 | 1M | SUM | v2 | 0.043 | 23,484 | 94.0 |
| A2 | 1M | MINMAX | v2 | 0.035 | 28,606 | 114.4 |
| A3 | 10M | SUM | v2 | 0.540 | 18,504 | 74.0 |
| A3 | 10M | MINMAX | v2 | 0.473 | 21,155 | 84.6 |
| A4 | 50M | SUM | v2 | 2.801 | 17,850 | 71.4 |
| A4 | 50M | MINMAX | v2 | 3.043 | 16,431 | 65.7 |

### 分析

- **CPU SIMD 性能极佳**:
  - 小数据量: 高达 **118 GB/s** 带宽利用
  - 大数据量: 稳定 65-85 GB/s
- **带宽利用率**: 16-30% (接近内存带宽限制)
- **GPU 优化价值**: 有限，CPU 已接近内存带宽上限

### 优化建议

1. **GPU 阈值大幅提高**: >= 100M 才考虑 GPU
2. **融合操作**: SUM+MIN+MAX 单次遍历
3. **分组聚合优化**: 原子操作改为分区聚合

---

## 四、Hash Join 算子测试

**SQL 语义**: `SELECT * FROM t1 JOIN t2 ON t1.key = t2.key`

### 测试结果

| 测试用例 | Build | Probe | 版本 | 加速器 | 时间(ms) | 吞吐量(M/s) | vs v3 |
|----------|-------|-------|------|--------|----------|-------------|-------|
| J1 | 10K | 100K | v3 | CPU | 0.056 | 1,973 | 1.00x |
| J1 | 10K | 100K | v4 | CPU Opt | 0.065 | 1,696 | 0.76x |
| J1 | 10K | 100K | UMA | **GPU** | 0.608 | 181 | 0.09x |
| J2 | 100K | 1M | v3 | CPU | 3.563 | 309 | 1.00x |
| J2 | 100K | 1M | v4 | CPU Opt | 3.409 | 323 | 1.05x |
| J2 | 100K | 1M | UMA | **GPU** | 0.888 | 1,239 | **4.01x** |
| J3 | 1M | 10M | v3 | CPU | 48.571 | 227 | 1.00x |
| J3 | 1M | 10M | UMA | **GPU** | 11.981 | 918 | **4.05x** |
| J4 | 5M | 50M | v3 | CPU | 202.191 | 272 | 1.00x |
| J4 | 5M | 50M | UMA | **GPU** | 138.867 | 396 | **1.46x** |

### 关键发现

#### ✅ GPU 显著加速场景
- **J2 (100K × 1M)**: **4.01x** 加速
- **J3 (1M × 10M)**: **4.05x** 加速 (最佳)

#### ⚠️ GPU 效果有限场景
- **J1 (10K × 100K)**: 0.09x (GPU 启动开销主导)
- **J4 (5M × 50M)**: 1.46x (内存带宽瓶颈)

### 分析

| 数据规模 | GPU 加速比 | 主要瓶颈 |
|----------|------------|----------|
| < 100K | < 0.1x | GPU 启动开销 |
| 100K - 10M | **3-5x** | 计算密集 (最佳区间) |
| > 10M | 1-2x | 内存带宽 |

### 优化建议

1. **提高 GPU 阈值**: probe_count >= 500K
2. **流水线执行**: 使用 SharedEvent 重叠 build 和 probe
3. **哈希表优化**: 使用 Cuckoo Hashing 减少冲突链
4. **结果缓冲**: 分批写回减少原子争用

---

## 五、TopK 算子测试

**SQL 语义**: `SELECT * FROM t ORDER BY col DESC LIMIT K`

### 测试结果 (基于先前基准测试)

| 测试用例 | 数据量 | K | 版本 | 时间(ms) | 吞吐量(M/s) | vs v4 |
|----------|--------|---|------|----------|-------------|-------|
| T1 | 1M | 10 | v4 Sample | 0.8 | 1,250 | 1.00x |
| T1 | 1M | 10 | v5 Count | 0.6 | 1,667 | 1.33x |
| T2 | 10M | 10 | v4 Sample | 3.2 | 3,125 | 1.00x |
| T2 | 10M | 10 | v5 Count | 2.8 | 3,571 | 1.14x |
| T3 | 10M | 100 | v4 Sample | 3.5 | 2,857 | 1.00x |
| T3 | 10M | 100 | v5 Count | 3.1 | 3,226 | 1.13x |

### 分析

- **v5 (Count-Based)** 在低基数场景优于 v4
- **GPU 优化空间**: 有限，CPU 采样预过滤已很高效

---

## 六、综合性能对比

### 各算子最佳加速比

| 算子 | 最佳版本 | 加速器 | 最佳加速比 | 适用场景 |
|------|----------|--------|------------|----------|
| Filter | v3 | CPU SIMD | - | 当前 CPU 最优 |
| Aggregate | v2 | CPU SIMD | - | 带宽受限，GPU 无优势 |
| **Join** | **UMA GPU** | **GPU** | **4.05x** | 100K-10M 数据规模 |
| TopK | v5 | CPU Count | 1.33x | 低基数场景 |

### 带宽利用率分析

| 算子 | 最高带宽 (GB/s) | 理论峰值占比 |
|------|-----------------|--------------|
| Aggregate | 118.5 | **29.6%** |
| Filter | 10.6 | 2.7% |
| Join | 4.96 | 1.2% |
| TopK | ~4.0 | 1.0% |

---

## 七、优化优先级建议

### 🔴 高优先级

1. **Join GPU 阈值优化**
   - 当前问题: 小数据量 GPU 反而慢
   - 建议: probe_count >= 500K 才启用 GPU
   - 预期收益: 避免小数据 GPU 回退

2. **Filter GPU kernel 优化**
   - 当前问题: GPU 比 CPU 慢
   - 建议:
     - 使用 SIMD4 向量化
     - 每线程处理 64+ 元素
     - 使用 threadgroup 内存缓存
   - 预期收益: 大数据量下 2-3x 加速

### 🟡 中优先级

3. **Join 结果写回优化**
   - 当前问题: 原子操作争用
   - 建议: 使用前缀和 + 批量写入
   - 预期收益: J4 场景提升到 2-3x

4. **Aggregate GPU 融合**
   - 建议: SUM+MIN+MAX 单 kernel 执行
   - 预期收益: 减少 kernel 启动开销

### 🟢 低优先级

5. **TopK GPU 实现**
   - 当前 CPU v5 已足够高效
   - 仅在 N > 50M 时考虑 GPU

6. **NPU 加速探索**
   - Bloom Filter 等哈希计算可尝试 BNNS

---

## 八、数据流分析

### 典型 SQL 执行路径

```
SELECT SUM(value), COUNT(*)
FROM orders
WHERE amount > 1000
GROUP BY region
```

| 阶段 | 算子 | 推荐加速器 | 原因 |
|------|------|------------|------|
| 1 | Filter | CPU SIMD | 高选择率，CPU 足够快 |
| 2 | Aggregate | CPU SIMD | 带宽受限 |
| 3 | Group By | CPU | 分组数少，GPU 无优势 |

```
SELECT t1.*, t2.name
FROM transactions t1
JOIN users t2 ON t1.user_id = t2.id
ORDER BY t1.amount DESC
LIMIT 10
```

| 阶段 | 算子 | 推荐加速器 | 原因 |
|------|------|------------|------|
| 1 | Join | **GPU** | 大表连接，4x 加速 |
| 2 | TopK | CPU | K=10 很小 |

---

## 九、结论

### 成功点

1. **Join UMA GPU** 实现 **4x** 加速，零拷贝架构有效
2. **Aggregate CPU SIMD** 达到 **118 GB/s**，接近内存带宽上限
3. **Filter CPU SIMD** 稳定 **2,500 M rows/s**

### 待改进

1. **GPU 启动开销** 在小数据量下主导
2. **带宽利用率** Filter/Join 仍有提升空间
3. **策略选择** 需要更智能的 CPU/GPU 切换

### 下一步

1. 编译并部署 Metal 着色器为 .metallib
2. 优化 Filter GPU kernel
3. 实现 Join 流水线执行
4. 添加基数/选择率自适应检测
