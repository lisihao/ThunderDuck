# ThunderDuck 全面性能基准测试报告 v3

> **版本**: v3.0 | **测试日期**: 2026-01-26 | **平台**: Apple Silicon M4

## 一、系统配置

| 配置项 | 详情 |
|-------|------|
| **硬件平台** | Apple Silicon M4 (ARM64 + Neon SIMD + AMX) |
| **CPU 加速器** | Neon SIMD (128-bit), vDSP, AMX 协处理器 |
| **GPU 加速器** | Metal GPU (统一内存架构) |
| **理论内存带宽** | ~400 GB/s (UMA) |
| **AMX/BLAS 状态** | ✓ 可用 |
| **Metal GPU 状态** | ✓ 可用 |
| **测试迭代** | 5 次 (预热 3 次) |

---

## 二、Filter 算子测试

### SQL 语义
```sql
SELECT * FROM table WHERE value > threshold
```

### 测试结果

| 测试场景 | 数据大小 | 硬件路径 | 结果数 | v5 时间 (μs) | DuckDB 时间 (μs) | vs DuckDB | 带宽 (GB/s) | 理论利用率 |
|---------|----------|----------|--------|-------------|-----------------|-----------|-------------|-----------|
| 100K 50% sel | 390 KB | CPU Neon | 50,164 | 38.0 | 231.7 | **6.1x** | 10.5 | 2.6% |
| 1M 50% sel | 3 MB | CPU Neon | 499,577 | 395.0 | 2,301.5 | **5.8x** | 10.1 | 2.5% |
| 5M 50% sel | 19 MB | CPU Neon | 2,500,806 | 893.9 | 12,847.8 | **14.4x** | 22.4 | 5.6% |
| 10M 50% sel | 38 MB | CPU Neon | 5,000,264 | 1,687.1 | 23,220.2 | **13.8x** | 23.7 | 5.9% |
| 10M 10% sel | 38 MB | CPU Neon | 999,727 | 794.3 | 6,041.8 | **7.6x** | 50.4 | 12.6% |
| 10M 90% sel | 38 MB | CPU Neon | 8,999,376 | 2,027.0 | 6,444.0 | **3.2x** | 19.7 | 4.9% |

### 分析

- **最佳实现**: v5 Neon SIMD
- **带宽利用**: 10-50 GB/s
- **vs DuckDB**: 3.2x - 14.4x 加速
- **关键发现**:
  - 低选择率 (10%) 时带宽利用率最高 (12.6%)
  - 高选择率 (90%) 时结果物化成为瓶颈
  - 大数据量 (5M+) 时加速比更稳定 (13-14x)

---

## 三、Aggregate 算子测试

### SQL 语义
```sql
SELECT SUM(value), MIN(value), MAX(value) FROM table
```

### 测试结果

| 测试场景 | 数据大小 | 硬件路径 | vDSP 时间 (μs) | 带宽 (GB/s) | 理论利用率 |
|---------|----------|----------|---------------|-------------|-----------|
| 100K | 390 KB | vDSP+MT | 9.4 | 127.2 | **31.8%** |
| 1M | 3 MB | vDSP+MT | 115.5 | 103.9 | **26.0%** |
| 5M | 19 MB | vDSP+MT | 413.1 | 145.2 | **36.3%** |
| 10M | 38 MB | vDSP+MT | 1,449.3 | 82.8 | **20.7%** |

### 分析

- **最佳实现**: vDSP 并行版本
- **带宽利用**: 80-145 GB/s (3次遍历计算)
- **关键发现**:
  - vDSP 利用 Apple Accelerate 框架高度优化
  - 5M 数据时达到峰值带宽利用 (36.3%)
  - 10M 数据时带宽下降 (可能触发 L2 缓存溢出)
- **优化建议**: 融合 SUM/MIN/MAX 为单次遍历，可提升 3x 带宽利用

---

## 四、Hash Join 算子测试

### SQL 语义
```sql
SELECT COUNT(*) FROM build b JOIN probe p ON b.key = p.key
```

### 测试结果

| 测试场景 | 数据大小 | 硬件路径 | 匹配数 | v3 时间 (μs) | DuckDB 时间 (μs) | vs DuckDB | 匹配率 |
|---------|----------|----------|--------|-------------|-----------------|-----------|-------|
| 10K×100K full | 429 KB | CPU Neon | 100,000 | 49.2 | 550.8 | **11.2x** | 100% |
| 100K×1M 10% | 4 MB | CPU Neon | 100,000 | 1,261.7 | 7,130.5 | **5.7x** | 10% |
| 100K×1M 50% | 4 MB | CPU Neon | 500,000 | 2,705.0 | 8,873.9 | **3.3x** | 50% |
| 100K×1M full | 4 MB | CPU Neon | 1,000,000 | 907.8 | 6,457.2 | **7.1x** | 100% |
| 1M×1M 10% | 7 MB | CPU Neon | 100,000 | 2,057.9 | 56,652.4 | **27.5x** | 10% |
| 1M×1M full | 7 MB | CPU Neon | 1,000,000 | 1,789.9 | 56,151.1 | **31.4x** | 100% |

### 分析

- **最佳实现**: v3 CPU Neon (10K-1M 数据规模)
- **vs DuckDB**: 3.3x - 31.4x 加速
- **关键发现**:
  - 大规模 Join (1M×1M) 加速比最高 (27-31x)
  - 中等匹配率 (50%) 时加速比最低 (3.3x)
  - CPU v3 在当前数据规模优于 GPU 实现
- **GPU 适用场景**: 10M+ 数据量时 GPU 并行优势才能体现

---

## 五、TopK 算子测试

### SQL 语义
```sql
SELECT value FROM table ORDER BY value DESC LIMIT K
```

### 测试结果

| 测试场景 | 数据大小 | 硬件路径 | v5 时间 (μs) | DuckDB 时间 (μs) | vs v3 | vs DuckDB | K 值 |
|---------|----------|----------|-------------|-----------------|-------|-----------|------|
| 100K K=10 | 390 KB | CPU Neon | 51.3 | 28.2 | 0.95x | 0.6x | 10 |
| 100K K=100 | 390 KB | CPU Neon | 11.8 | 41.4 | 1.12x | **3.5x** | 100 |
| 1M K=10 | 3 MB | CPU Neon | 54.9 | 564.6 | **8.71x** | **10.3x** | 10 |
| 1M K=100 | 3 MB | CPU Neon | 54.2 | 474.9 | 0.96x | **8.8x** | 100 |
| 5M K=10 | 19 MB | CPU Neon | 298.1 | 2,328.3 | **7.86x** | **7.8x** | 10 |
| 10M K=10 | 38 MB | CPU Neon | 595.6 | 4,815.2 | **8.11x** | **8.1x** | 10 |
| 10M K=100 | 38 MB | CPU Neon | 503.9 | 4,720.9 | 1.05x | **9.4x** | 100 |
| 10M K=1000 | 38 MB | CPU Neon | 697.0 | 4,948.0 | 1.04x | **7.1x** | 1000 |

### 分析

- **最佳实现**: v5 自适应策略
- **vs DuckDB**: 3.5x - 10.3x 加速 (K>=100)
- **关键发现**:
  - **K 值小 + 大数据量**: v5 采样策略表现最优 (8x 加速)
  - **K 值大**: v3 堆排序与 v5 性能接近
  - **小数据量 K=10**: DuckDB 反而更快 (可能是 partial_sort 优化)
- **v5 策略**: 根据数据量自动选择 (小数据用堆，大数据用采样)

---

## 六、Vector Similarity 算子测试

### SQL 语义
```sql
SELECT dot_product(query, candidate) FROM vectors
```

### 测试结果

| 测试场景 | 数据大小 | 硬件路径 | AMX 时间 (μs) | Neon 时间 (μs) | AMX/Neon | 带宽 (GB/s) | 理论利用率 |
|---------|----------|----------|-------------|---------------|----------|-------------|-----------|
| 10K×128 | 4 MB | AMX/BLAS | 18.9 | 90.4 | **4.8x** | 271.1 | **67.8%** |
| 10K×256 | 9 MB | AMX/BLAS | 35.7 | 223.5 | **6.3x** | 286.9 | **71.7%** |
| 10K×512 | 19 MB | AMX/BLAS | 257.1 | 638.2 | **2.5x** | 79.6 | 19.9% |
| 50K×256 | 48 MB | AMX/BLAS | 814.1 | 1,099.1 | **1.4x** | 62.9 | 15.7% |
| 100K×128 | 48 MB | AMX/BLAS | 832.8 | 935.0 | **1.1x** | 61.5 | 15.4% |
| 100K×256 | 97 MB | AMX/BLAS | 1,625.9 | 2,275.6 | **1.4x** | 63.0 | 15.7% |
| 100K×512 | 195 MB | AMX/BLAS | 3,043.5 | 9,064.6 | **3.0x** | 67.3 | 16.8% |
| 500K×256 | 488 MB | AMX/BLAS | 7,728.8 | 11,632.5 | **1.5x** | 66.2 | 16.6% |
| 1M×128 | 488 MB | AMX/BLAS | 7,110.1 | 9,381.1 | **1.3x** | 72.0 | 18.0% |

### 分析

- **最佳实现**: AMX/BLAS (所有场景)
- **AMX vs Neon**: 1.1x - 6.3x 加速
- **峰值带宽**: 287 GB/s (10K×256，71.7% 理论利用率)
- **关键发现**:
  - **小批量高维**: AMX 优势最大 (4-6x)
  - **大批量**: AMX 优势减小但仍然最优 (1.1-1.5x)
  - **带宽随数据量增加下降**: 大数据集触发内存带宽瓶颈
- **结论**: AMX/BLAS 在 M4 上始终是最优选择

---

## 七、性能总结

### 综合对比表

| 算子 | 最佳实现 | vs DuckDB | 带宽利用 | 瓶颈分析 |
|------|----------|-----------|----------|---------|
| **Filter** | v5 Neon SIMD | 3x - 14x | 10-50 GB/s | 结果物化开销 |
| **Aggregate** | vDSP 并行 | N/A | 80-145 GB/s | 多次遍历 |
| **Hash Join** | v3 CPU Neon | 3x - 31x | N/A | 中等匹配率场景 |
| **TopK** | v5 自适应 | 3x - 10x | N/A | 小数据量 K 小 |
| **Vector Similarity** | AMX/BLAS | N/A | 60-287 GB/s | 已达峰值 |

### 关键发现

1. **✓ Hash Join 大幅领先**: 1M×1M 场景达到 **31x** 加速比
2. **✓ Vector Similarity 高带宽**: AMX 实现 **287 GB/s** 峰值 (71.7% 理论)
3. **✓ Filter 稳定加速**: 大数据量稳定 **13-14x** 加速
4. **⚠ TopK 小数据**: 小数据量 K=10 时 DuckDB 更优
5. **⚠ Aggregate**: 多次遍历影响带宽利用率

### 优化优先级

| 优先级 | 算子 | 当前状态 | 目标 | 方法 |
|--------|------|----------|------|------|
| **P0** | 大规模 Hash Join | CPU 主导 | GPU 加速 10M+ | 分区 Hash Join |
| **P1** | Aggregate 融合 | 3次遍历 | 1次遍历 | SUM/MIN/MAX 融合 |
| **P2** | TopK 小数据 | DuckDB 更优 | 超越 DuckDB | 优化堆算法 |
| **P3** | 端到端 GPU | 未实现 | 完整流水线 | GPU 查询执行器 |

---

## 八、硬件执行路径总结

| 算子 | CPU Scalar | CPU Neon SIMD | vDSP/AMX | GPU Metal |
|------|------------|---------------|----------|-----------|
| Filter | ✗ 基准 | ✓ 最优 | N/A | ⚠ 大数据优 |
| Aggregate | ✗ 基准 | ⚠ 次优 | ✓ 最优 | ⚠ 大数据优 |
| Hash Join | ✗ 基准 | ✓ 最优 | N/A | ⚠ 超大数据优 |
| TopK | ✗ 基准 | ✓ 最优 | N/A | ⚠ 实验中 |
| Vector Sim | ✗ 基准 | ⚠ 次优 | ✓ 最优 | ⚠ 大数据优 |

**图例**: ✓ 最优 | ⚠ 条件最优 | ✗ 非最优

---

## 九、基准测试命令

```bash
# 编译
make lib

# 运行综合测试
clang++ -std=c++17 -O3 -mcpu=native -I./include -fobjc-arc \
    benchmark/comprehensive_benchmark_v3.cpp \
    -o build/comprehensive_benchmark_v3 \
    -L./build -lthunderduck \
    -framework Metal -framework Foundation -framework Accelerate

./build/comprehensive_benchmark_v3
```

---

*报告生成: ThunderDuck Benchmark Suite v3.0*
*测试时间: 2026-01-26*
