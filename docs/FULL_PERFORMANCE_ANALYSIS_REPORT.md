# ThunderDuck 全面性能分析报告

> **版本**: 1.0 | **日期**: 2026-01-26 | **平台**: Apple Silicon M4 (UMA)

## 一、测试环境

| 配置项 | 详情 |
|-------|------|
| 平台 | Apple Silicon M4 |
| 理论内存带宽 | 400 GB/s |
| CPU 加速器 | Neon SIMD (128-bit) |
| GPU 加速器 | Metal GPU (UMA) |
| 预热次数 | 3 |
| 测量次数 | 5 |

---

## 二、性能总览

### 2.1 各算子 vs DuckDB 加速比

| 算子 | 平均加速比 | 最大加速比 | 最小加速比 | 平均带宽 |
|------|-----------|-----------|-----------|---------|
| **Hash Join** | **32.0x** | 81.7x | 11.1x | 4.87 GB/s |
| **TopK** | **6.8x** | 10.3x | 0.6x | 46.82 GB/s |
| **Filter** | **4.4x** | 6.6x | 1.0x | 12.68 GB/s |
| **Aggregate** | **2.5x** | 7.9x | 0.0x | 68.55 GB/s |

### 2.2 带宽利用率

| 算子 | 平均带宽 | 理论利用率 | 瓶颈 |
|------|---------|-----------|------|
| Aggregate | 68.55 GB/s | **17.1%** | 接近最优 |
| TopK | 46.82 GB/s | **11.7%** | 堆操作开销 |
| Filter | 12.68 GB/s | **3.2%** | 结果物化 |
| Hash Join | 4.87 GB/s | **1.2%** | 哈希表探测 |

---

## 三、详细测试结果

### 3.1 Filter 算子

**SQL 语义**: `SELECT * FROM t WHERE val > threshold`

| 数据量 | 选择率 | 时间(μs) | 带宽(GB/s) | vs DuckDB |
|-------|-------|---------|-----------|-----------|
| 100K | 50% | 42 | 14.26 | **5.7x** |
| 1M | 50% | 401 | 14.96 | **6.6x** |
| 5M | 50% | 2315 | 12.96 | **5.6x** |
| 10M | 50% | 5283 | 11.36 | **5.2x** |
| 10M | 90% | 6836 | 11.11 | **1.0x** |
| 10M | 10% | 3842 | 11.45 | **2.3x** |

**分析**:
- 50% 选择率: 稳定 5-6x 加速
- 90% 选择率: 几乎无加速 (1.0x) - **需优化**
- 10% 选择率: 仅 2.3x 加速 - **需优化**
- 带宽利用率仅 3% 左右

### 3.2 Aggregate 算子

**SQL 语义**: `SELECT SUM(val) / MIN(val) / MAX(val) FROM t`

| 数据量 | 操作 | 时间(μs) | 带宽(GB/s) | vs DuckDB |
|-------|------|---------|-----------|-----------|
| 100K | SUM | 5.9 | 67.42 | 0.0x |
| 1M | SUM | 61.4 | 65.14 | 0.0x |
| 5M | SUM | 313 | 63.86 | 0.0x |
| 10M | SUM | 544 | 73.49 | 0.0x |
| 1M | MIN/MAX | 53.8 | 74.32 | **7.9x** |
| 10M | MIN/MAX | 596 | 67.08 | **7.2x** |

**分析**:
- SUM: 加速比为 0 是因为基线实现问题 (实际 ~17% 带宽利用)
- MIN/MAX: 稳定 7-8x 加速
- 带宽利用率 16-18%，较好

### 3.3 TopK 算子

**SQL 语义**: `SELECT val FROM t ORDER BY val DESC LIMIT K`

| 数据量 | K | 时间(μs) | 带宽(GB/s) | vs DuckDB |
|-------|---|---------|-----------|-----------|
| 100K | 10 | 64.8 | 6.17 | **0.6x** |
| 100K | 100 | 13.6 | 29.43 | **3.6x** |
| 1M | 10 | 61.4 | 65.15 | **8.5x** |
| 1M | 100 | 56.2 | 71.21 | **10.3x** |
| 5M | 10 | 413 | 48.43 | **6.5x** |
| 10M | 10 | 795 | 50.34 | **7.2x** |
| 10M | 100 | 622 | 64.33 | **8.8x** |
| 10M | 1000 | 1013 | 39.48 | **8.5x** |

**分析**:
- **100K K=10 场景比 DuckDB 慢 (0.6x)** - 需优化
- 1M+ 数据量: 稳定 6-10x 加速
- K=100 时性能最优

### 3.4 Hash Join 算子

**SQL 语义**: `SELECT COUNT(*) FROM build b JOIN probe p ON b.key = p.key`

| 规模 | 匹配率 | 时间(μs) | 带宽(GB/s) | vs DuckDB |
|------|-------|---------|-----------|-----------|
| 10K×100K | 100% | 157 | 7.91 | **38.4x** |
| 10K×100K | 50% | 233 | 3.61 | **20.8x** |
| 10K×100K | 10% | 228 | 2.29 | **11.1x** |
| 100K×1M | 100% | 1321 | 9.39 | **81.7x** |
| 100K×1M | 50% | 3055 | 2.75 | **15.5x** |
| 100K×1M | 10% | 1317 | 3.95 | **13.7x** |
| 1M×1M | 100% | 2801 | 5.71 | **51.6x** |
| 1M×1M | 10% | 2622 | 3.36 | **23.3x** |

**分析**:
- **全匹配场景表现最优**: 38-82x 加速
- 50% 匹配: 15-21x 加速
- 10% 匹配: 11-23x 加速
- 带宽利用率低 (0.6-2.3%)

### 3.5 GPU vs CPU

| 规模 | GPU 时间 | CPU 时间 | GPU/CPU |
|------|---------|---------|---------|
| 100K×1M | 6151μs | 1321μs | **0.19x** |
| 1M×1M | 8375μs | 2801μs | **0.58x** |

**分析**: GPU 在当前数据规模下不如 CPU

---

## 四、优化机会分析

### 4.1 高优先级 (P0)

| 问题 | 当前性能 | 目标 | 优化方向 |
|------|---------|------|---------|
| **Filter 高选择率 (90%)** | 1.0x | 5x+ | 批量输出优化 |
| **Filter 低选择率 (10%)** | 2.3x | 5x+ | 分支预测优化 |
| **TopK 小数据 K=10** | 0.6x | 3x+ | 启发式阈值调整 |

### 4.2 中优先级 (P1)

| 问题 | 当前性能 | 目标 | 优化方向 |
|------|---------|------|---------|
| **Filter 带宽利用** | 3% | 20%+ | 减少结果物化开销 |
| **Hash Join 带宽利用** | 1-2% | 10%+ | 缓存友好的哈希表 |
| **GPU Hash Join** | 0.2-0.6x | 2x+ | 更大数据规模测试 |

### 4.3 低优先级 (P2)

| 问题 | 当前性能 | 目标 | 优化方向 |
|------|---------|------|---------|
| **Aggregate 带宽** | 17% | 30%+ | 融合 SUM+MIN+MAX |
| **TopK K=1000** | 8.5x | 12x+ | 并行堆合并 |

---

## 五、根因分析

### 5.1 Filter 高选择率慢

**问题**: 90% 选择率时只有 1.0x 加速

**根因**:
1. **结果物化开销**: 需要写入 90% 的索引到输出数组
2. **分支预测失败**: 高选择率下分支几乎总是 taken
3. **内存写带宽**: 输出数组写入成为瓶颈

**解决方案**:
```cpp
// 当前: 逐个写入
if (mask & (1 << i)) indices[count++] = i;

// 优化: SIMD compress 批量写入
uint32x4_t compressed = vcompressq_u32(indices_vec, mask);
vst1q_u32(output + count, compressed);
count += __builtin_popcount(mask);
```

### 5.2 TopK 小数据慢

**问题**: 100K K=10 时只有 0.6x

**根因**:
1. **采样开销**: v5 使用采样策略，在小数据上有额外开销
2. **堆初始化**: 构建 K 元素堆的固定成本
3. **DuckDB 优化**: partial_sort 对小 K 有特殊优化

**解决方案**:
```cpp
// 动态策略选择
if (count < 100000 && k < 20) {
    // 使用 partial_sort 替代采样
    return topk_partial_sort(data, count, k, result);
}
```

### 5.3 Hash Join 带宽利用低

**问题**: 只有 0.6-2.3% 带宽利用

**根因**:
1. **随机访问**: 哈希表探测是随机内存访问
2. **缓存失效**: 每次探测可能触发缓存 miss
3. **指针追踪**: 链式哈希表的指针追踪延迟

**解决方案**:
```cpp
// 软件预取
for (size_t i = 0; i < probe_count; i += 8) {
    // 预取下 8 个 bucket
    for (int j = 0; j < 8; ++j) {
        __builtin_prefetch(&buckets[hash(probe_keys[i + j + 16]) & mask]);
    }
    // 处理当前 8 个
    ...
}
```

---

## 六、优化路线图

### 阶段 1: Filter 优化 (1-2 周)

1. **SIMD compress 输出**: 使用 NEON vcompressq 批量写入
2. **分支消除**: 使用条件移动替代分支
3. **预期目标**: 所有选择率 5x+ 加速

### 阶段 2: TopK 小数据优化 (1 周)

1. **策略阈值调整**: 小数据直接使用 partial_sort
2. **堆算法优化**: 使用 SIMD 并行堆操作
3. **预期目标**: 100K K=10 达到 3x+ 加速

### 阶段 3: Hash Join 优化 (2-3 周)

1. **批量预取**: 8-16 个 probe 键同时预取
2. **缓存分区**: Radix 分区减少缓存 miss
3. **GPU 大规模测试**: 10M+ 数据验证 GPU 优势
4. **预期目标**: 带宽利用 10%+

---

## 七、总结

### 优势

- **Hash Join**: 11-82x 加速，远超 DuckDB
- **TopK**: 大数据量稳定 6-10x 加速
- **Aggregate MIN/MAX**: 7-8x 加速

### 需改进

| 场景 | 当前 | 目标 |
|------|------|------|
| Filter 90% 选择率 | 1.0x | 5x+ |
| Filter 10% 选择率 | 2.3x | 5x+ |
| TopK 100K K=10 | 0.6x | 3x+ |
| GPU Hash Join | 0.2-0.6x | 2x+ |

### 下一步行动

1. **立即**: 修复 Filter 高/低选择率问题
2. **短期**: 优化 TopK 小数据场景
3. **中期**: 提升 Hash Join 带宽利用率
4. **长期**: GPU 大规模数据优化

---

*报告生成: ThunderDuck Performance Analysis*
*日期: 2026-01-26*
