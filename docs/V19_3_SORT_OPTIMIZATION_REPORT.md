# ThunderDuck V19.3 排序优化评估报告

> 版本: V19.3 | 日期: 2026-01-27 | 平台: Apple M4 Max (10 核心)

## 一、优化方案评估

### 1.1 测试的优化点

| 优先级 | 优化项 | 实现方式 | 预期收益 |
|--------|--------|----------|----------|
| P0 | 多线程并行排序 | 8 线程分段排序 + 级联合并 | 4-6x |
| P1 | SIMD 归并优化 | ARM Neon 加速两路归并 | 1.5-2x (归并阶段) |
| P2 | Cache 感知分块 | L1/L2 自适应算法选择 | 10-20% |

### 1.2 实现详情

```cpp
// P0: 多线程并行排序
constexpr size_t V19_3_NUM_THREADS = 8;
constexpr size_t V19_3_MIN_PARALLEL_SIZE = 500000;

// P2: Cache 感知阈值
constexpr size_t V19_3_L1_THRESHOLD = 8 * 1024;    // 8K 元素 (32KB)
constexpr size_t V19_3_L2_THRESHOLD = 512 * 1024;  // 512K 元素 (2MB)

// 算法:
// 1. 数据分成 8 段，每段并行使用 radix sort
// 2. 级联两两合并 (log2(8)=3 轮)
```

## 二、性能测试结果

### 2.1 完整测试数据

| 数据量 | std::sort | radix_sort_v2 | V19.3 parallel | V19.3 vs radix_v2 |
|--------|-----------|---------------|----------------|-------------------|
| 1K | 0.008 ms | 0.006 ms | 0.006 ms | 1.00x |
| 10K | 0.188 ms | 0.031 ms | 0.031 ms | 1.00x |
| 100K | 3.543 ms | 0.216 ms | 0.224 ms | 0.96x |
| **1M** | 40.37 ms | 2.42 ms | 4.75 ms | **0.51x** |
| **10M** | 471.5 ms | 29.3 ms | 48.1 ms | **0.61x** |
| **100M** | 5585 ms | 309 ms | 498 ms | **0.62x** |

### 2.2 结果分析

**V19.3 并行排序在所有数据规模上都慢于现有的 radix_sort_v2：**

- 1M 数据: 0.51x (慢 2 倍)
- 10M 数据: 0.61x (慢 1.6 倍)
- 100M 数据: 0.62x (慢 1.6 倍)

## 三、性能分析

### 3.1 为什么并行排序没有超越 radix_sort_v2

1. **radix_sort_v2 已经是 O(n) 算法**
   - 使用 11-11-10 bit 分组，仅 3 趟
   - 对 M4 Max 的高内存带宽（400 GB/s）友好
   - 单线程即可达到 ~1.5 GB/s 带宽利用率

2. **并行排序的合并开销**
   - 8 线程意味着 log2(8) = 3 轮合并
   - 每轮合并都需要处理全部 n 个元素
   - 总工作量: n（排序）+ 3n（合并）= 4n

3. **线程开销**
   - 线程创建/销毁
   - 同步开销
   - 缓存失效

### 3.2 理论分析

```
单线程 radix sort:
  工作量 = 3n (3 趟 radix)
  时间复杂度 = O(n)

并行排序 (8 线程):
  排序阶段: 3n/8 (每线程) = 0.375n
  合并阶段: n × log2(8) = 3n
  总工作量 = 0.375n + 3n ≈ 3.4n

理论加速比 = 3n / 3.4n ≈ 0.88x (略慢)
实际测试 = 0.61x (考虑同步开销后更慢)
```

## 四、结论

### 4.1 不采纳的优化

| 优化项 | 原因 |
|--------|------|
| P0: 多线程并行排序 | 合并开销抵消并行收益，0.61x vs radix_v2 |
| P1: SIMD 归并优化 | 归并本身不是瓶颈，radix 不需要归并 |
| P2: Cache 感知分块 | 现有 radix_sort_v2 已有类似优化 |

### 4.2 保持现状

**ThunderDuck 排序模块维持 V19.2 版本**：

- 小数据 (< 256): std::sort
- 中大数据: radix_sort_i32_v2 (11-11-10 bit, 3 趟)
- TopK: GPU 加速 (V6) - 8x vs DuckDB

### 4.3 排序模块性能现状

| 算法 | 数据量 | 性能 | vs std::sort |
|------|--------|------|--------------|
| radix_sort_v2 | 1M | 2.42 ms | **16.7x** |
| radix_sort_v2 | 10M | 29.3 ms | **16.1x** |
| radix_sort_v2 | 100M | 309 ms | **18.1x** |

**现有的 radix_sort_v2 已经非常高效，无需进一步优化。**

## 五、后续建议

如果未来需要进一步优化排序性能，可考虑：

1. **并行 radix sort**（而非分段排序+合并）
   - 并行计数阶段
   - 全局前缀和
   - 分桶散射（需要处理写冲突）

2. **GPU radix sort**
   - 利用 Metal GPU 的大规模并行能力
   - 适合 100M+ 数据

3. **外部排序集成**
   - 与 DuckDB 的外排序机制集成
   - 适合超大数据集

---

**结论：V19.3 排序优化未通过性能验证，不采纳。保持 V19.2 为当前最优版本。**
